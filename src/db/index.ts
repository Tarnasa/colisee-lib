/**
 * @module db
 */

import * as Knex from "knex";
import * as _ from "lodash";

import logger from "../logger";

const DB_HOST: string = _.defaultTo<string>(process.env.DB_HOST, "localhost");
const DB_PORT: string = _.defaultTo<string>(process.env.DB_PORT, "5432");
const DB_USER: string = _.defaultTo<string>(process.env.DB_USER, "postgres");
const DB_PASS: string = _.defaultTo<string>(process.env.DB_PASS, "postgres");
const DB_NAME: string = _.defaultTo<string>(process.env.DB_NAME, "postgres");

export const TEAMS_TABLE = "teams";
export const SUBMISSIONS_TABLE = "submissions";
export const GAMES_TABLE = "games";
export const GAMES_SUBMISSIONS_TABLE = "games_submissions";

export const TEAM_SUBMISSIONS_STATUSES = ["queued", "building", "finished", "failed"];
export const GAME_STATUSES = ["queued", "playing", "finished", "failed"];

/**
 * Main Knex connection. Make queries though this using the Knex API.
 */
export const connection = Knex({
    client: "pg",
    connection: {
        database: DB_NAME,
        host: DB_HOST,
        password: DB_PASS,
        port: DB_PORT,
        user: DB_USER,
    },
});

/**
 * Initializes the database with Colisee tables
 * @param dryRun - Doesn't actually execute SQL if true.
 * @param force - Allow function to initialize a production database
 */
export async function initializeDatabase(dryRun: boolean = true): Promise<string> {

    const conn: Knex = (()=>{
        if(dryRun) {
            return Knex({client: "pg"});
        } else {
            return connection;
        }
    })();

    // Create All Tables
    const tables: [string, (def: Knex.TableBuilder) => any][] = [
        [TEAMS_TABLE, table => {
            table.increments("id");
            table.string("name", 64)
                .notNullable()
                .unique();

            table.string("contact_email", 64)
                .notNullable()
                .unique();
            table.string("password", 256)
                .notNullable();
            table.boolean("is_eligible")
                .notNullable();

            table.timestamps(true, true);
        }],

        [SUBMISSIONS_TABLE, table => {
            table.increments("id");
            table.integer("team_id")
                .unsigned()
                .references(`${TEAMS_TABLE}.id`);

            table.integer("version").notNullable();
            table.enu("status", TEAM_SUBMISSIONS_STATUSES).notNullable();

            table.string("submission_url");
            table.string("log_url");
            table.string("image_name")
                .comment("The docker image of the submission contained on the Arena Docker Registry");

            table.timestamps(true, true);

            // Constraints
            table.unique(["team_id", "version"]);
        }],

        [GAMES_TABLE, table => {
            table.increments("id");
            table.enu("status", GAME_STATUSES);

            table.string("win_reason");
            table.string("lose_reason");
            table.integer("winner_id")
                .unsigned()
                .references(`${SUBMISSIONS_TABLE}.id`)
                .comment("The id of the winning submission");

            table.string("log_url")
                .comment("Link to the game log.");

            table.timestamps(true, true);
        }],

        [GAMES_SUBMISSIONS_TABLE, table => {
            table.increments("id");

            table.integer("submission_id")
                .unsigned()
                .notNullable()
                .references(`${SUBMISSIONS_TABLE}.id`)
                .comment("The submission that is a player in the linked game.");

            table.integer("game_id")
                .unsigned()
                .notNullable()
                .references(`${GAMES_TABLE}.id`)
                .comment("The game that is/was played by the linked player.");

            table.string("output_url")
                .comment("Link to the output generated by the linked submission.");

            table.timestamps(true, true);
        }],
    ];

    const sqlStrings = [];
    for (const [table, def] of tables) {
        const t = conn.schema.createTable(table, def);
        sqlStrings.push(t.toString());
        try {
            await t;
        } catch(e) {
            logger.warn(e);
        }
    }

    return `${sqlStrings.join(";\n")};\n`;
}
