/**
 * @module db
 */

import * as Knex from "knex";
import * as _ from "lodash";

import logger from "../logger";

const DB_HOST: string = _.defaultTo<string>(process.env.DB_HOST, "localhost");
const DB_PORT: string = _.defaultTo<string>(process.env.DB_PORT, "5432");
const DB_USER: string = _.defaultTo<string>(process.env.DB_USER, "postgres");
const DB_PASS: string = _.defaultTo<string>(process.env.DB_PASS, "postgres");
const DB_NAME: string = _.defaultTo<string>(process.env.DB_NAME, "postgres");

export const TEAMS_TABLE = "teams";
export const SUBMISSIONS_TABLE = "submissions";
export const GAMES_TABLE = "games";
export const GAMES_SUBMISSIONS_TABLE = "games_submissions";

export const TEAM_ROLES = ["user", "admin"];
export type TEAM_ROLE = "user" | "admin";

export const SUBMISSION_STATUSES = ["queued", "building", "finished", "failed"];
export type SUBMISSION_STATUS_TYPE = "queued" | "building" | "finished" | "failed";

export const GAME_STATUSES = ["queued", "playing", "finished", "failed"];
export type GAME_STATUS_TYPE = "queued" | "playing" | "finished" | "failed";

/**
 * Main Knex connection. Make queries though this using the Knex API.
 */
export const connection = Knex({
    client: "pg",
    connection: {
        database: DB_NAME,
        host: DB_HOST,
        password: DB_PASS,
        port: DB_PORT,
        user: DB_USER,
    },
});

/**
 * toString function that outputs an object's contents when called implicitly.
 */
// export function toString<T>(thing: T) {
//     let output = "";
//     for (const i in thing) {
//         output = output + i + ":" + thing[i] + "/n";
//     }
//     return output;
// }

/**
 * Initializes the database with Colisee tables
 * @param dryRun - Doesn't actually execute SQL if true.
 * @param force - Allow function to initialize a production database
 */
export async function initializeDatabase(dryRun: boolean = true): Promise<string> {

    const conn: Knex = (() => {
        if (dryRun) {
            return Knex({ client: "pg" });
        } else {
            return connection;
        }
    })();

    // Create All Tables
    const tables: [string, (def: Knex.TableBuilder) => any][] = [
        [TEAMS_TABLE, table => {
            table.increments("id");
            table.string("name", 64)
                .notNullable()
                .unique();

            table.string("contact_email", 64)
                .notNullable()
                .unique();
            table.string("contact_name", 64)
                .notNullable();
            table.integer("hash_iterations")
                .defaultTo(0)
                .notNullable();
            table.boolean("is_eligible")
                .notNullable();
            table.string("password", 256)
                .notNullable();
            table.enu("role", TEAM_ROLES)
                .notNullable();
            table.string("salt", 256)
                .notNullable();

            table.timestamps(true, true);
        }],

        [SUBMISSIONS_TABLE, table => {
            table.increments("id");
            table.integer("team_id")
                .unsigned()
                .references(`${TEAMS_TABLE}.id`);

            table.integer("version").notNullable();
            table.enu("status", SUBMISSION_STATUSES).notNullable();

            table.string("submission_url");
            table.string("log_url");
            table.string("image_name")
                .comment("The docker image of the submission contained on the Arena Docker Registry");

            table.timestamps(true, true);

            // Constraints
            table.unique(["team_id", "version"]);
        }],

        [GAMES_TABLE, table => {
            table.increments("id");
            table.enu("status", GAME_STATUSES)
                .notNullable();

            table.string("win_reason");
            table.string("lose_reason");
            table.integer("winner_id")
                .unsigned()
                .references(`${SUBMISSIONS_TABLE}.id`)
                .comment("The id of the winning submission");

            table.string("log_url")
                .comment("Link to the game log.");

            table.timestamps(true, true);
        }],

        [GAMES_SUBMISSIONS_TABLE, table => {
            table.increments("id");

            table.integer("submission_id")
                .unsigned()
                .notNullable()
                .references(`${SUBMISSIONS_TABLE}.id`)
                .comment("The submission that is a player in the linked game.");

            table.integer("game_id")
                .unsigned()
                .notNullable()
                .references(`${GAMES_TABLE}.id`)
                .comment("The game that is/was played by the linked player.");

            table.string("output_url")
                .comment("Link to the output generated by the linked submission.");

            table.timestamps(true, true);
        }],
    ];

    const sqlStrings = [];
    for (const [table, def] of tables) {
        const t = conn.schema.createTable(table, def);
        sqlStrings.push(t.toString());
        try {
            await t;
        } catch (e) {
            logger.warn(e);
        }
    }

    return `${sqlStrings.join(";\n")};\n`;
}

export interface Team {
    id: number;
    name: string;
    contactEmail: string;
    password: string;
    isEligible: boolean;

    createdAt: Date;
    updatedAt: Date;
}

export function rowsToTeams(rows: any[]): Team[] {
    return rows.map((row): Team => {
        return {
            contactEmail: row.contact_email,
            createdAt: new Date(row.created_at),
            id: row.id,
            isEligible: row.is_eligible,
            name: row.name,
            password: row.password,
            updatedAt: new Date(row.updated_at),
        };
    });
}

export interface Submission {
    id: number;
    teamId: number;
    version: number;
    status: SUBMISSION_STATUS_TYPE;

    submissionUrl: string | null;
    logUrl: string | null;
    imageName: string | null;

    createdAt: Date;
    updatedAt: Date;
}

export function rowsToSubmissions(rows: any[]): Submission[] {
    return rows.map((row): Submission => {
        return {
            createdAt: new Date(row.created_at),
            id: row.id,
            imageName: row.image_name,
            logUrl: row.log_url,
            status: row.status,
            submissionUrl: row.submission_url,
            teamId: row.team_id,
            updatedAt: new Date(row.updated_at),
            version: row.version,
        };
    });
}

export interface Game {
    id: number;
    status: GAME_STATUS_TYPE;
    winReason: string | null;
    loseReason: string | null;
    winnerId: number | null;
    logUrl: string | null;

    createdAt: Date;
    updatedAt: Date;
}

export function rowsToGames(rows: any[]): Game[] {
    return rows.map((row): Game => {
        return {
            createdAt: new Date(row.created_at),
            id: row.id,
            logUrl: row.log_url,
            loseReason: row.lose_reason,
            status: row.status,
            updatedAt: new Date(row.updated_at),
            winReason: row.win_reason,
            winnerId: row.winner_id,
        };
    });
}

export interface GameSubmission {
    id: number;
    submissionId: number;
    gameId: number;
    outputUrl: string | null;

    createdAt: Date;
    updatedAt: Date;
}

export function rowsToGameSubmissions(rows: any[]): GameSubmission[] {
    return rows.map((row): GameSubmission => {
        return {
            createdAt: new Date(row.created_at),
            gameId: row.game_id,
            id: row.id,
            outputUrl: row.output_url,
            submissionId: row.submission_id,
            updatedAt: new Date(row.updated_at),
        };
    });
}
